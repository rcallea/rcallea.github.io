<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Flipbook PDF - Doble p√°gina (ajustado)</title>

  <!-- PDF.js local -->
  <script src="libs/pdfjs/pdf.js"></script>

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    .flipbook-container {
      width: 100%;
      max-width: 1100px;
      margin: 1rem;
      background: #020617;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border: 1px solid #1f2937;
    }

    .flipbook-header {
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #020617;
      border-bottom: 1px solid #1f2937;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .flipbook-title {
      font-size: 0.95rem;
      font-weight: 500;
      color: #f9fafb;
      white-space: nowrap;
    }

    .flipbook-file-input label {
      font-size: 0.8rem;
      background: #111827;
      color: #e5e7eb;
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      border: 1px solid #374151;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s, transform 0.1s;
    }

    .flipbook-file-input label:hover {
      background: #1f2937;
      border-color: #facc15;
    }

    .flipbook-file-input input {
      display: none;
    }

    .flipbook-viewer {
      position: relative;
      background: radial-gradient(circle at top, #0f172a 0%, #020617 50%, #020617 100%);
      padding: 1.25rem;
      /* que el viewer tenga algo de alto para calcular el ajuste */
      min-height: 60vh;
    }

    .page-wrapper {
      position: relative;
      margin: 0 auto;
      max-width: 100%;
      perspective: 1600px;
      overflow: hidden; /* recorta solo el ‚Äúmarco‚Äù del libro, no las p√°ginas internas */
    }

    /* ---------- DOBLE P√ÅGINA SIEMPRE LADO A LADO ---------- */
    .page-spread {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: stretch;
      gap: 0;
      flex-wrap: nowrap;   /* nunca se apilan una debajo de la otra */
      overflow-x: auto;    /* si no caben, scroll horizontal */
      overflow-y: hidden;
    }

    .page {
      flex: 0 0 auto;      /* ancho definido por el canvas */
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .page-inner {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .page-left {
      border-right: 2px solid #020617; /* ‚Äúlomo‚Äù */
    }

    .page-right {
      border-left: 2px solid #020617;
    }

    canvas {
      display: block;
      background: #111827;
      border-radius: 0;
      box-shadow: 0 10px 20px rgba(0,0,0,0.5);
	  position: relative;
	  z-index: 1;
      /* el tama√±o visible lo controla JS (style.width / style.height) */
    }

    /* Capa para enlaces clicables */
	.link-layer {
	  position: absolute;
	  inset: 0;
	  z-index: 10;               /* nos aseguramos de que quede por encima del canvas */
	  pointer-events: none; /* permite que SOLO .pdf-link reciba clicks */
	}

	.pdf-link {
	  position: absolute;
	  pointer-events: auto; /* recibe clics */
	  cursor: pointer;          /* feedback visual de que es clicable */
	}

    .pdf-link:hover {
      outline: 2px solid rgba(250, 204, 21, 0.6);
    }

    /* Animaci√≥n pasar p√°gina */
    .page-wrapper.flip-next {
      animation: flipNext 0.55s ease-out;
    }

    .page-wrapper.flip-prev {
      animation: flipPrev 0.55s ease-out;
    }

    @keyframes flipNext {
      0%   { transform: rotateY(0deg); }
      40%  { transform: rotateY(-16deg) translateX(-8px); }
      100% { transform: rotateY(0deg); }
    }

    @keyframes flipPrev {
      0%   { transform: rotateY(0deg); }
      40%  { transform: rotateY(16deg) translateX(8px); }
      100% { transform: rotateY(0deg); }
    }

    .flipbook-controls {
      padding: 0.75rem 1rem 1rem;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      background: #020617;
    }

    .button-group {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    button.flip-btn {
      border: 1px solid #374151;
      background: #111827;
      color: #e5e7eb;
      font-size: 0.8rem;
      padding: 0.35rem 0.7rem;
      border-radius: 999px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      transition: background 0.2s, border-color 0.2s, transform 0.05s;
    }

    button.flip-btn:hover {
      background: #1f2937;
      border-color: #facc15;
    }

    button.flip-btn:active {
      transform: translateY(1px);
    }

    button.flip-btn:disabled {
      opacity: 0.35;
      cursor: default;
      border-color: #111827;
    }

    .page-info {
      font-size: 0.8rem;
      color: #9ca3af;
      white-space: nowrap;
    }

    .zoom-info {
      font-size: 0.75rem;
      color: #9ca3af;
      text-align: right;
      min-width: 70px;
    }

    @media (max-width: 768px) {
      .flipbook-viewer {
        padding: 0.8rem;
      }
      /* NOTA: no tocamos page-spread ni page para que siga doble p√°gina */
    }

    @media (max-width: 640px) {
      .flipbook-header {
        flex-direction: column;
        align-items: flex-start;
      }
      .flipbook-title {
        font-size: 0.85rem;
      }
      .flipbook-controls {
        padding: 0.6rem 0.8rem 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="flipbook-container">
    <header class="flipbook-header">
      <div class="flipbook-title">
        üìñ Flipbook PDF doble p√°gina
      </div>
      <div class="flipbook-file-input">
        <label>
          üìÇ Cargar PDF‚Ä¶
          <input type="file" id="fileInput" accept="application/pdf" />
        </label>
      </div>
    </header>

    <main class="flipbook-viewer">
      <div class="page-wrapper" id="pageWrapper">
        <div class="page-spread">
          <div class="page page-left">
            <div class="page-inner">
              <canvas id="leftCanvas"></canvas>
              <div class="link-layer" id="leftLinks"></div>
            </div>
          </div>
          <div class="page page-right">
            <div class="page-inner">
              <canvas id="rightCanvas"></canvas>
              <div class="link-layer" id="rightLinks"></div>
            </div>
          </div>
        </div>
      </div>
    </main>

    <footer class="flipbook-controls">
      <div class="button-group">
        <button class="flip-btn" id="prevPageBtn">
          ‚¨ÖÔ∏è Anterior
        </button>
        <button class="flip-btn" id="nextPageBtn">
          Siguiente ‚û°Ô∏è
        </button>
        <span class="page-info" id="pageInfo">
          P√°gina - / -
        </span>
      </div>

      <div class="button-group">
        <button class="flip-btn" id="zoomOutBtn">‚ûñ Zoom</button>
        <button class="flip-btn" id="zoomResetBtn">üîÑ 100%</button>
        <button class="flip-btn" id="zoomInBtn">‚ûï Zoom</button>
        <span class="zoom-info" id="zoomInfo">100%</span>
      </div>
    </footer>
  </div>

  <script>
    // Compatibilidad con PDF.js
    var pdfjsLib = window["pdfjsLib"] || window["pdfjs-dist/build/pdf"];
    if (!pdfjsLib) {
      console.error("No se pudo encontrar pdfjsLib. Revisa que libs/pdfjs/pdf.js exista.");
    } else {
      pdfjsLib.GlobalWorkerOptions.workerSrc = "libs/pdfjs/pdf.worker.js";
    }

    const DEFAULT_PDF_URL = "libro.pdf";

    const leftCanvas   = document.getElementById("leftCanvas");
    const rightCanvas  = document.getElementById("rightCanvas");
    const leftCtx      = leftCanvas.getContext("2d");
    const rightCtx     = rightCanvas.getContext("2d");
    const pageWrapper  = document.getElementById("pageWrapper");
    const leftLinks    = document.getElementById("leftLinks");
    const rightLinks   = document.getElementById("rightLinks");

    const prevPageBtn  = document.getElementById("prevPageBtn");
    const nextPageBtn  = document.getElementById("nextPageBtn");
    const zoomInBtn    = document.getElementById("zoomInBtn");
    const zoomOutBtn   = document.getElementById("zoomOutBtn");
    const zoomResetBtn = document.getElementById("zoomResetBtn");
    const pageInfo     = document.getElementById("pageInfo");
    const zoomInfo     = document.getElementById("zoomInfo");
    const fileInput    = document.getElementById("fileInput");

    let pdfDoc = null;
    let totalPages = 0;
    let spreads = [];           // [{left, right}, ...]
    let currentSpreadIndex = 0;

    // Viewport base (escala 1) de la p√°gina 1 para calcular auto-ajuste al alto
    let baseViewport = null;

    // Zoom
    let baseScale = 1.0;
    let currentScale = 1.0;
    const minScale = 0.5;
    const maxScale = 3.0;
    const zoomStep = 0.2;

    let pageRendering = false;
    let pendingSpreadIndex = null;

    // Construye spreads: portada a la derecha, luego pares
    function buildSpreads(numPages) {
      const result = [];
      // Primer spread: solo p√°gina 1 a la derecha
      result.push({ left: null, right: 1 });
      // Luego spreads de dos p√°ginas: (2,3), (4,5), ...
      for (let p = 2; p <= numPages; p += 2) {
        const left = p;
        const right = p + 1 <= numPages ? p + 1 : null;
        result.push({ left, right });
      }
      return result;
    }

    // Calcula escala para ajustar la altura al viewport
    function computeBaseScale() {
      if (!baseViewport) return 1.0;
      const viewer = document.querySelector(".flipbook-viewer");
      const availableHeight = viewer
        ? viewer.clientHeight
        : window.innerHeight * 0.8;

      // Dejamos un margen del 10%
      const scale = (availableHeight * 0.9) / baseViewport.height;
      return scale > 0 ? scale : 1.0;
    }

    function updateZoomDisplay() {
      zoomInfo.textContent = `${Math.round(currentScale * 100)}%`;
    }

    // Renderiza una sola p√°gina en su canvas con enlaces
	function renderPageToCanvas(pageNum, canvas, ctx, linkLayer) {
	  if (!pageNum) {
		// P√°gina en blanco: limpiamos y salimos
		linkLayer.innerHTML = "";
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		return Promise.resolve();
	  }

	  return pdfDoc.getPage(pageNum).then(function (page) {
		const viewport = page.getViewport({ scale: currentScale });
		const outputScale = window.devicePixelRatio || 1;

		canvas.width  = Math.floor(viewport.width * outputScale);
		canvas.height = Math.floor(viewport.height * outputScale);

		// Tama√±o visible (depende del zoom)
		canvas.style.width  = viewport.width + "px";
		canvas.style.height = viewport.height + "px";

		const transform = outputScale !== 1
		  ? [outputScale, 0, 0, outputScale, 0, 0]
		  : null;

		linkLayer.innerHTML = "";

		const renderTask = page.render({
		  canvasContext: ctx,
		  viewport: viewport,
		  transform: transform
		});

		// ‚¨á‚¨á AQU√ç EST√Å EL CAMBIO IMPORTANTE
		return renderTask.promise
		  .then(function () {
			// usamos intent:'display' para asegurarnos de obtener las anotaciones visibles
			return page.getAnnotations({ intent: "display" });
		  })
		  .then(function (annots) {
		  annots.forEach(function (a) {
			  if (a.subtype !== "Link" || !a.rect) return;

			  // 1. Convertimos el rect√°ngulo del PDF a coordenadas de viewport
			  //    (origen arriba-izquierda, como CSS)
			  const vpRect = viewport.convertToViewportRectangle(a.rect);
			  const x1 = Math.min(vpRect[0], vpRect[2]);
			  const y1 = Math.min(vpRect[1], vpRect[3]);
			  const x2 = Math.max(vpRect[0], vpRect[2]);
			  const y2 = Math.max(vpRect[1], vpRect[3]);

			  const rectWidth  = x2 - x1;
			  const rectHeight = y2 - y1;

			  // 2. Pasamos a porcentajes respecto al viewport
			  const leftPct   = (x1 / viewport.width)  * 100;
			  const topPct    = (y1 / viewport.height) * 100;
			  const widthPct  = (rectWidth  / viewport.width)  * 100;
			  const heightPct = (rectHeight / viewport.height) * 100;

			  const linkEl = document.createElement("a");
			  linkEl.className = "pdf-link";
			  linkEl.style.left   = leftPct + "%";
			  linkEl.style.top    = topPct + "%";
			  linkEl.style.width  = widthPct + "%";
			  linkEl.style.height = heightPct + "%";

			  if (a.url) {
				// üîó Enlace externo
				linkEl.href = a.url;
				linkEl.target = "_blank";
			  } else if (a.dest) {
				// üìÑ Enlace interno (otra p√°gina del mismo PDF)
				linkEl.href = "#";
				linkEl.addEventListener("click", function (e) {
				  e.preventDefault();

				  pdfDoc.getDestination(a.dest)
					.then(function (destArray) {
					  if (!destArray) return;
					  const ref = destArray[0];
					  return pdfDoc.getPageIndex(ref);
					})
					.then(function (pageIndex) {
					  if (pageIndex == null) return;
					  const targetPage = pageIndex + 1;

					  let targetSpreadIndex = currentSpreadIndex;
					  for (let i = 0; i < spreads.length; i++) {
						const s = spreads[i];
						if (s.left === targetPage || s.right === targetPage) {
						  targetSpreadIndex = i;
						  break;
						}
					  }

					  currentSpreadIndex = targetSpreadIndex;
					  queueRenderSpread(currentSpreadIndex);
					  updateButtons();
					})
					.catch(function (err) {
					  console.error("Error navegando a enlace interno:", err);
					});
				});
			  } else {
				return; // sin url ni dest, no hacemos nada
			  }

			  linkLayer.appendChild(linkEl);
			});
		  });
	  });
	}

    // Hace que una p√°gina en blanco tenga el mismo tama√±o que otra
    function copySizeAndClear(sourceCanvas, targetCanvas, targetCtx, targetLinks) {
      targetLinks.innerHTML = "";
      const w = sourceCanvas.width;
      const h = sourceCanvas.height;
      targetCanvas.width  = w;
      targetCanvas.height = h;
      targetCanvas.style.width  = sourceCanvas.style.width;
      targetCanvas.style.height = sourceCanvas.style.height;
      targetCtx.clearRect(0, 0, w, h);
    }

    // Renderiza el spread actual (doble p√°gina)
    function renderSpread(spreadIndex, flipDirection) {
      if (!pdfDoc || !spreads.length) return;
      const spread = spreads[spreadIndex];
      const leftPageNum  = spread.left;
      const rightPageNum = spread.right;

      pageRendering = true;

      if (flipDirection === "next") {
        pageWrapper.classList.remove("flip-prev");
        void pageWrapper.offsetWidth;
        pageWrapper.classList.add("flip-next");
      } else if (flipDirection === "prev") {
        pageWrapper.classList.remove("flip-next");
        void pageWrapper.offsetWidth;
        pageWrapper.classList.add("flip-prev");
      }

      const tasks = [];

      if (leftPageNum) {
        tasks.push(renderPageToCanvas(leftPageNum, leftCanvas, leftCtx, leftLinks));
      } else {
        // Solo limpiamos; la igualaci√≥n de tama√±o se hace luego, seg√∫n la derecha
        leftLinks.innerHTML = "";
        leftCtx.clearRect(0, 0, leftCanvas.width, leftCanvas.height);
      }

      if (rightPageNum) {
        tasks.push(renderPageToCanvas(rightPageNum, rightCanvas, rightCtx, rightLinks));
      } else {
        rightLinks.innerHTML = "";
        rightCtx.clearRect(0, 0, rightCanvas.width, rightCanvas.height);
      }

      Promise.all(tasks)
        .then(function () {
          // Si es portada (left null, right != null), igualamos el ancho del blanco al de la derecha
          if (!leftPageNum && rightPageNum) {
            copySizeAndClear(rightCanvas, leftCanvas, leftCtx, leftLinks);
          }
          // Si la √∫ltima p√°gina queda sola a la izquierda (left != null, right null)
          if (leftPageNum && !rightPageNum) {
            copySizeAndClear(leftCanvas, rightCanvas, rightCtx, rightLinks);
          }

          pageRendering = false;
          updatePageInfo();

          if (pendingSpreadIndex !== null) {
            const nextIndex = pendingSpreadIndex;
            pendingSpreadIndex = null;
            renderSpread(
              nextIndex,
              nextIndex > spreadIndex ? "next" : "prev"
            );
          }
        })
        .catch(function (err) {
          console.error("Error renderizando spread:", err);
          pageRendering = false;
        });
    }

    function queueRenderSpread(spreadIndex, flipDirection) {
      if (pageRendering) {
        pendingSpreadIndex = spreadIndex;
      } else {
        renderSpread(spreadIndex, flipDirection);
      }
    }

    function onPrevSpread() {
      if (!pdfDoc || currentSpreadIndex <= 0) return;
      currentSpreadIndex--;
      queueRenderSpread(currentSpreadIndex, "prev");
      updateButtons();
    }

    function onNextSpread() {
      if (!pdfDoc || currentSpreadIndex >= spreads.length - 1) return;
      currentSpreadIndex++;
      queueRenderSpread(currentSpreadIndex, "next");
      updateButtons();
    }

    function setZoom(newScale) {
      if (!pdfDoc) return;
      currentScale = Math.min(maxScale, Math.max(minScale, newScale));
      updateZoomDisplay();
      queueRenderSpread(currentSpreadIndex);
    }

    function onZoomIn() {
      setZoom(currentScale + zoomStep);
    }

    function onZoomOut() {
      setZoom(currentScale - zoomStep);
    }

    function onZoomReset() {
      setZoom(baseScale);
    }

    function updateButtons() {
      prevPageBtn.disabled = !pdfDoc || currentSpreadIndex <= 0;
      nextPageBtn.disabled = !pdfDoc || currentSpreadIndex >= spreads.length - 1;
      if (!pdfDoc) {
        pageInfo.textContent = "P√°gina - / -";
      }
    }

    function updatePageInfo() {
      if (!pdfDoc || !spreads.length) {
        pageInfo.textContent = "P√°gina - / -";
        return;
      }
      const spread = spreads[currentSpreadIndex];
      const left = spread.left;
      const right = spread.right;

      if (left && right) {
        pageInfo.textContent = `P√°ginas ${left}‚Äì${right} de ${totalPages}`;
      } else if (right && !left) {
        pageInfo.textContent = `P√°gina ${right} de ${totalPages}`;
      } else if (left && !right) {
        pageInfo.textContent = `P√°gina ${left} de ${totalPages}`;
      } else {
        pageInfo.textContent = `P√°gina - / ${totalPages}`;
      }
    }

    // Carga PDF desde URL (libro.pdf por defecto)
    function loadPdfFromUrl(url) {
      if (!pdfjsLib || !url) return;

      const loadingTask = pdfjsLib.getDocument(url);
      loadingTask.promise
        .then(function (pdf) {
          pdfDoc = pdf;
          totalPages = pdf.numPages;
          return pdfDoc.getPage(1);
        })
        .then(function (page1) {
          // Guardamos viewport base (escala 1) y calculamos escala para alto de ventana
          baseViewport = page1.getViewport({ scale: 1.0 });
          baseScale = computeBaseScale();
          currentScale = baseScale;

          spreads = buildSpreads(totalPages);
          currentSpreadIndex = 0;

          updateButtons();
          updateZoomDisplay();
          renderSpread(currentSpreadIndex);
        })
        .catch(function (err) {
          console.error("Error cargando PDF:", err);
          alert("No se pudo cargar el PDF. Revisa que 'libro.pdf' est√© en la misma carpeta.");
        });
    }

    // Carga PDF desde archivo local
    function loadPdfFromFile(file) {
      if (!pdfjsLib || !file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        const typedArray = new Uint8Array(e.target.result);
        const loadingTask = pdfjsLib.getDocument({ data: typedArray });

        loadingTask.promise
          .then(function (pdf) {
            pdfDoc = pdf;
            totalPages = pdf.numPages;
            return pdfDoc.getPage(1);
          })
          .then(function (page1) {
            baseViewport = page1.getViewport({ scale: 1.0 });
            baseScale = computeBaseScale();
            currentScale = baseScale;

            spreads = buildSpreads(totalPages);
            currentSpreadIndex = 0;

            updateButtons();
            updateZoomDisplay();
            renderSpread(currentSpreadIndex);
          })
          .catch(function (err) {
            console.error("Error cargando PDF desde archivo:", err);
            alert("No se pudo leer el archivo PDF.");
          });
      };
      reader.readAsArrayBuffer(file);
    }

    // Eventos UI
    prevPageBtn.addEventListener("click", onPrevSpread);
    nextPageBtn.addEventListener("click", onNextSpread);
    zoomInBtn.addEventListener("click", onZoomIn);
    zoomOutBtn.addEventListener("click", onZoomOut);
    zoomResetBtn.addEventListener("click", onZoomReset);

    fileInput.addEventListener("change", function (e) {
      const file = e.target.files[0];
      if (file) {
        loadPdfFromFile(file);
      }
    });

    document.addEventListener("keydown", function (e) {
      if (e.key === "ArrowRight") {
        onNextSpread();
      } else if (e.key === "ArrowLeft") {
        onPrevSpread();
      } else if ((e.ctrlKey || e.metaKey) && e.key === "+") {
        e.preventDefault();
        onZoomIn();
      } else if ((e.ctrlKey || e.metaKey) && e.key === "-") {
        e.preventDefault();
        onZoomOut();
      }
    });

    // Recalcular escala base cuando cambie el tama√±o de la ventana
    window.addEventListener("resize", function () {
      if (!pdfDoc || !baseViewport) return;
      const factor = currentScale / baseScale; // cu√°nto se hab√≠a alejado/acercado el usuario
      baseScale = computeBaseScale();
      currentScale = baseScale * factor;
      updateZoomDisplay();
      queueRenderSpread(currentSpreadIndex);
    });

    // Carga inicial
    if (DEFAULT_PDF_URL && pdfjsLib) {
      loadPdfFromUrl(DEFAULT_PDF_URL);
    } else {
      updateButtons();
    }
  </script>
</body>
</html>
